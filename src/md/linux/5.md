---
title: Linux学习笔记（五）：shell脚本，awk，sed，服务管理
index: false
icon: laptop-code
category:
  - Linux
  - 学习笔记
---

## 1. Shell 脚本

> `Shell` 脚本是一种使用 `Shell` 编写的脚本，它可以在 Linux 系统中执行各种任务。

### 1.1 变量

- **声明变量**： 使用 `export` 命令声明变量。

	```bash
	export 变量名
	```

- **修改变量**： 在子 Shell 中修改变量，相当于创建了一个新的变量，不会影响父 Shell 中的变量。

- **删除变量**： 使用 `unset` 命令删除变量。

	```bash
	unset 变量名
	```

- **声明类型**： 使用 `declare` 命令声明变量的类型。

	```bash
	declare -i 变量名  # 声明整型变量
	declare -r 变量名  # 声明只读变量
	declare -x 变量名  # 声明环境变量
	```

### 1.2 特殊变量

- **\$**： `$` 符号用于引用特殊变量。
- **\$?**： `$?` 用于获取上一个命令的退出状态码。
- **\$-**： `$-` 用于获取当前 Shell 的选项。
- **\$#**： `$#` 用于获取传递给脚本的参数个数。
- **\$\$**： `$$` 用于获取当前 Shell 的进程 ID。
- **\$_**： `$_` 用于获取前一条命令的最后一个参数。
- **\${!变量名}**： `${!变量名}` 用于获取变量的值。

### 1.3 间接引用

- **`${变量名}`**： 使用 `${变量名}` 进行间接引用，可以访问变量的值。

### 1.4 逻辑运算符

- **${a:-b}**： 如果 `a` 为空，则使用 `b`。
- **${a:=b}**： 如果 `a` 为空，则将 `b` 赋值给 `a`。
- **${a:?b}**： 如果 `a` 为空，则将 `b` 写入标准错误并退出。
- **${a:+b}**： 如果 `a` 为空，则返回空字符串，否则返回 `b`。

### 1.5 文件操作
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/832c1eef2ca54f3cb0eb7ad6c98a84cc.png)


- **文件存在**： `test -e 文件名`
- **文件不存在**： `test ! -e 文件名`
- **文件可读**： `test -r 文件名`
- **文件可写**： `test -w 文件名`
- **文件可执行**： `test -x 文件名`
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f049c12dc8b4446690eb47bf8c48c7a6.png)

### 1.6 数组


- **声明数组**： 使用 `declare -a` 命令声明数组。

```bash
declare -a 数组名
```

- **访问数组元素**： 使用 `${数组名[索引]}` 访问数组元素。

### 1.7 运算

- **算术运算**： 使用 `expr` 命令进行算术运算。

```bash
expr 10 + 20
```

- **条件运算**： 使用 `test` 命令进行条件运算。

```bash
test $x -eq $y
```
## 2. Shell 脚本深入扩展

>Shell 脚本作为一种灵活的工具，可以应用于各种场景。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9dac5bc0d318430bba9579a5553c2419.png)

### 2.1 变量与参数

- **位置参数**： `$1`, `$2`, `$3` 等用于获取传递给脚本的参数。
- **特殊参数**： `$*`, `$@`, `$#` 等用于处理特殊参数。
- `$*`：所有参数作为一个单词。
- `$@`：所有参数作为单独的单词。
- `$#`：传递给脚本的参数个数。
- **获取命令行**： `"$@"` 或 `"$*"` 可以获取完整的命令行。

### 2.2 控制流

- **if 语句**： 用于条件判断。

```bash
if [ 条件 ]; then
  # 条件为真时执行的命令
fi
```

- **case 语句**： 用于多条件匹配。

```bash
case 变量 in
  情况1)
    # 情况1对应的命令
    ;;
  情况2)
    # 情况2对应的命令
    ;;
  *)
    # 默认情况
    ;;
esac
```

- **for 循环**： 用于循环遍历。

```bash
for 变量 in 列表; do
  # 循环体
done
```

- **while 循环**： 用于循环直到条件为假。

```bash
while [ 条件 ]; do
  # 循环体
done
```

### 2.3 函数

- **定义函数**： 使用 `function` 关键字定义函数。

```bash
function 函数名() {
  # 函数体
}
```

- **调用函数**： 使用函数名调用函数。

```bash
函数名 [参数]
```

### 2.4 输入输出

- **读取输入**： 使用 `read` 命令读取用户输入。

```bash
read 变量名
```

- **输出文本**： 使用 `echo` 命令输出文本。

```bash
echo "文本内容"
```

- **重定向输出**： 使用 `>` 和 `>>` 运算符将输出重定向到文件。

```bash
命令 > 文件
命令 >> 文件
```

### 2.5 脚本结构

- **注释**： 使用 `#` 符号添加注释。
- **空白字符**： 空白字符（空格、制表符等）用于分隔命令和参数。
- **管道**： 使用 `|` 运算符将一个命令的输出作为另一个命令的输入。

### 2.6 脚本调试

- **打印变量值**： 使用 `echo` 命令打印变量的值，用于调试。
- **设置断点**： 使用 `set -x` 命令开启调试模式，打印每条命令及其参数。

### 2.7 Shell 类型

- **Bash**： 最常用的 Shell，功能强大，易于学习和使用。
- **Zsh**： 功能丰富的 Shell，支持语法高亮、别名等功能。
- **Ksh**： 类似于 Bash，但有一些不同的特性。

## 3. 强大的文本处理工具`awk`
>`awk` 是一种强大的文本处理工具，它可以将文本文件视为由记录和字段组成的数据流，并允许用户对数据进行复杂的操作。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/837e7f1d432a4986994c02770c4e683d.png#pic_center)

### 3.1 基本概念

- **记录（Record）**： 每一行文本都是一个记录。记录通常由换行符分隔。
- **字段（Field）**： 每个记录由多个字段组成，字段通常由空白字符（空格、制表符等）分隔。
- **字段分隔符（FS）**： 默认的字段分隔符是空白字符，可以使用 `-F` 选项指定其他分隔符，例如 `-F,` 使用逗号作为分隔符。
- **模式匹配（Pattern）**： `awk` 可以根据模式匹配特定的记录。
- **动作（Action）**： 对匹配的记录执行的动作，通常涉及输出或修改数据。

### 3.2 语法

```bash
awk [选项] '模式 {动作}' 文件...
```

- **选项**： 用于指定 `awk` 的行为，例如 `-F` 指定字段分隔符。
- **模式**： 用于匹配记录，可以是正则表达式或比较操作符。
- **动作**： 对匹配的记录执行的操作，可以是输出、打印、修改等。

### 3.3 基本用法

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c285274327054dc79c1d5b58b814306a.png#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9fbe5dfbaa0143dd8b75691580e76b70.png#pic_center)


- **打印所有记录**：

```bash
awk '{print}' 文件
```

- **打印第 1 列**：

```bash
awk -F '\t' '{print $1}' 文件
```

- **打印第二列大于 10 的记录**：

```bash
awk -F '\t' '$2 > 10 {print}' 文件
```

- **计算所有记录的总和**：

```bash
awk -F '\t' '{sum += $2} END {print sum}' 文件
```

- **打印包含特定单词的记录**：

```bash
awk '/特定单词/ {print}' 文件
```

### 3.4 高级用法

- **嵌套模式**： 可以使用多个模式进行嵌套匹配。
- **循环和条件语句**： `awk` 支持循环和条件语句，可以执行更复杂的操作。
- **内置函数**： `awk` 提供了大量的内置函数，例如 `length()`, `sqrt()`, `strftime()` 等。
- **用户定义函数**： 可以编写自己的函数，并将其添加到 `awk` 脚本中。


## 4. awk扩展用法与高级特性

### 4.1 复杂模式匹配

`awk` 支持正则表达式，这使得模式匹配更加灵活。可以使用 `~` 和 `!~` 运算符来分别匹配和排除正则表达式。

```bash
# 打印包含特定模式的记录
awk '$1 ~ /模式/ {print}' 文件

# 打印不包含特定模式的记录
awk '$1 !~ /模式/ {print}' 文件
```

### 4.2 字段引用

`awk` 提供了多种字段引用方式，包括直接引用 `$1`, `$2`, `$3` 等，以及使用 `NF`（字段总数）、`$0`（整个记录）和 `NR`（记录数）等特殊变量。

```bash
# 打印所有记录的第三列
awk '{print $3}' 文件

# 打印每条记录的行号和所有字段
awk '{print NR, $0}' 文件
```

### 4.3 数组和关联数组

`awk` 支持数组和关联数组，可以用来存储和操作复杂的数据结构。

```bash
# 初始化一个关联数组
awk '{
    a[$1]++
} END {
    for (key in a) print key, a[key]
}' 文件
```

### 4.4 流控制语句

`awk` 支持循环和条件语句，如 `for`, `while`, `if` 等。

```bash
# 使用 for 循环遍历数组
awk 'BEGIN {
    for (i = 1; i <= 10; i++) print i
}'

# 使用 if 语句进行条件判断
awk '{if ($1 > 5) print $0}' 文件
```

### 4.5 内置变量和函数

`awk` 提供了大量的内置变量和函数，可以用于字符串操作、数学运算、日期处理等。

```bash
# 使用内置函数 split
awk -F ',' '{split($0,a," "); print a[1]}' 文件

# 使用内置变量 RS 和 RS
awk -v RS='-' '{print}' 文件
```

### 4.6 用户定义变量和函数

可以在 `awk` 脚本中定义自己的变量和函数。

```bash
awk '
    # 定义用户变量
    var = 10

    # 定义用户函数
    add(a, b) { return a + b }

    {
        # 使用用户变量和函数
        print var
        print add($1, $2)
    }
' 文件
```
### 4.7 处理二进制数据

`awk` 可以处理二进制文件，使用 `-b` 选项。

```bash
awk -b '{print $0}' 二进制文件
```

### 4.8 嵌套 `awk` 脚本

可以使用一个 `awk` 脚本作为另一个 `awk` 脚本的输入。

```bash
awk '{
    # 处理第一行
    print $0 > "output1"
    # 处理第二行
    print $0 >> "output1"
}' 文件 | awk '{
    # 处理输出文件
    print $0
}'
```
## 5. awk在shell脚本中的使用
>`awk` 在 shell 脚本中是非常有用的，因为它可以用于处理和转换文本数据，这在脚本编写中是非常常见的任务。
### 5.1 简单文本处理

在 shell 脚本中，可以使用 `awk` 来执行简单的文本处理任务，比如打印文件的每一行。

```bash
#!/bin/bash

# 打印文件中的每一行
awk '{print}' filename

# 将输出重定向到另一个文件
awk '{print}' filename > output.txt
```

### 5.2 字段提取

`awk` 可以用来提取文本文件的特定列。

```bash
#!/bin/bash

# 提取第一列
awk -F, '{print $1}' filename

# 使用自定义字段分隔符
awk -F; '{print $2, $3}' filename
```

### 5.3 数据过滤

使用 `awk` 可以根据条件过滤数据。

```bash
#!/bin/bash

# 打印第二列大于 10 的行
awk -F, '$2 > 10' filename

# 打印包含特定单词的行
awk '/特定单词/ {print}' filename
```

### 5.4 数据计算

`awk` 可以用来对数据进行数学计算。

```bash
#!/bin/bash

# 计算所有记录的第二列总和
awk -F, '{sum += $2} END {print sum}' filename

# 计算平均值
awk -F, '{total += $2; count++} END {print total / count}' filename
```

### 5.5 数据排序

`awk` 可以用来对数据进行排序。

```bash
#!/bin/bash

# 按第二列排序
awk -F, '{print $2, $0}' filename | sort -n | awk '{print $2, $0}'

# 按第一列逆序排序
awk -F, '{print $1, $0}' filename | sort -nr | awk '{print $1, $0}'
```

### 5.6 数据转换

`awk` 可以用来转换数据格式。

```bash
#!/bin/bash

# 将 CSV 转换为 JSON
awk -F, '{printf "{\"%s\": \"%s\"}\n", $1, $2}' filename > output.json
```

### 5.7 复杂数据处理

在更复杂的脚本中，`awk` 可以嵌入在循环或条件语句中，进行更复杂的数据处理。

```bash
#!/bin/bash

# 循环遍历文件并处理每一行
while IFS= read -r line; do
    # 使用 awk 处理每一行
    awk '{print $1, $2}' <<< "$line"
done < filename
```

### 5.8 作为子shell

在 shell 脚本中，可以将 `awk` 命令放在子shell中执行，以避免在后台执行。

```bash
#!/bin/bash

awk '{print}' filename &
wait
```

### 注意事项

- 当在 shell 脚本中使用 `awk` 时，确保文件名和变量名没有特殊字符，或者使用引号将其引起来，以避免解析错误。
- 使用 `IFS`（内部字段分隔符）可以改变字段分隔符，这在处理包含空格的文件名时非常有用。
- 在处理大量数据时，`awk` 可能会消耗大量内存，特别是在进行复杂的数据处理时。

## 6. 强大的文本处理工具`sed`
> `sed`（Stream Editor）是一个强大的文本处理工具，它允许用户对文本进行编辑、转换、过滤等操作，而不需要直接对原始文件进行修改。`sed` 处理的是文本流，通常来自文件或标准输入（stdin）。

### 6.1 基本概念

- **流编辑**：`sed` 是一个流编辑器，它一次处理一行文本。
- **命令行编辑**：`sed` 可以在命令行上直接编辑文本，也可以从文件中读取文本。
- **模式匹配**：`sed` 可以基于模式来选择文本行进行操作。
- **替换**：`sed` 的主要功能之一是替换文本。

### 6.2 语法

```bash
sed [选项] [命令] [输入文件]
```

- **选项**：用于指定 `sed` 的行为，例如 `-n` 用于抑制默认的自动打印。
- **命令**：用于指定对文本进行的操作，如 `p`（打印）、`s`（替换）等。
- **输入文件**：指定输入文件名，也可以是 `-'` 来表示从标准输入读取。

### 6.3 基本用法


- **打印匹配模式的行**：

```bash
sed -n '/模式/p' 文件
```

- **替换文本**：

```bash
sed 's/旧文本/新文本/g' 文件
```

这里，`s` 是替换命令，`/旧文本/` 是被查找的模式，`/新文本/` 是要替换的文本，`g` 是全局替换标志。

### 6.4 高级用法

- **删除行**：

```bash
sed '/模式/d' 文件
```

这里，`d` 是删除命令。

- **添加行**：

```bash
sed '/模式/i 添加的文本' 文件
```

这里，`i` 是插入命令。

- **替换并打印**：

```bash
sed '/模式/s/旧文本/新文本/g' 文件
```

这里，`p` 命令会打印替换后的行。

### 注意事项

- `sed` 的替换操作默认只替换每行的第一个匹配项。要替换所有匹配项，需要使用全局替换标志 `g`。
- `sed` 的模式匹配是按行进行的，如果模式包含换行符，需要特别处理。
- `sed` 的命令可以链式组合，形成复杂的文本处理流程。

## 7. sed的扩展用法与高级特性

### 7.1 使用地址范围

`sed` 允许你指定地址范围，这意味着你可以对文本中的特定行或行范围进行操作。

- **指定单行**：

```bash
sed '3p' 文件  # 打印第三行
```

- **指定多行范围**：

```bash
sed '1,3p' 文件  # 打印第一行到第三行
```

- **反向指定**：

```bash
sed '3,$p' 文件  # 打印第三行到文件末尾
```

### 7.2 使用正则表达式

`sed` 支持复杂的正则表达式，这使得模式匹配更加灵活。

- **使用正则表达式进行匹配**：

```bash
sed '/[0-9]\+/p' 文件  # 打印包含一个或多个数字的行
```

- **使用括号分组**：

```bash
sed 's/\([0-9]\+\)/\1 square/s' 文件  # 将数字替换为其平方
```

### 7.3 使用宏和函数

`sed` 允许你定义宏和函数，这使得你可以重用代码。

- **定义宏**：

```bash
sed -E '/pattern/{x;N;G;}' 文件  # 使用宏处理多行文本
```

- **使用函数**：

```bash
sed -E '{
    s/\([0-9]+\)/\1*2/;  # 定义一个简单的函数
    p;
}' 文件
```

### 7.4 使用管道和重定向

`sed` 可以与其他命令结合使用，通过管道（|）和重定向（>）进行更复杂的文本处理。

- **使用管道**：

```bash
cat 文件 | sed 's/old/new/g'  # 将 cat 命令的输出通过 sed 处理
```

- **使用重定向**：

```bash
sed 's/old/new/g' 文件 > 新文件  # 将 sed 的输出重定向到新文件
```

### 7.5 使用 `sed` 进行文本转换

`sed` 可以用来进行各种文本转换，如转换行结束符、替换字符等。

- **转换行结束符**：

```bash
sed 's/\r$//' 文件  # 将 Windows 行结束符 (\r\n) 转换为 Unix 行结束符 (\n)
```

- **替换字符**：

```bash
sed 's/字符1/字符2/g' 文件
```

### 7.6 使用 `sed` 进行批量操作

`sed` 可以用于批量操作，比如同时替换多个模式。

```bash
sed -E '{
    s/模式1/替换文本1/g;
    s/模式2/替换文本2/g;
    p;
}' 文件
```

## 8. sed在shell脚本的使用
> 在shell脚本中使用`sed`可以极大地提高脚本处理文本数据的能力。

### 8.1 替换文本

在脚本中，可以使用`sed`来替换文件中的文本。

```bash
#!/bin/bash

# 替换文件中所有的'old'为'new'
sed -i 's/old/new/g' filename
```

这里，`-i`选项表示直接修改文件，`s/old/new/g`是替换命令，表示替换所有出现的'old'为'new'。

### 8.2 条件替换

有时候你可能只想替换符合特定条件的文本。

```bash
#!/bin/bash

# 只替换第一行中出现的'old'为'new'
sed -i '1s/old/new/g' filename
```

### 8.3 复合命令

在脚本中，你可以将多个`sed`命令组合起来。

```bash
#!/bin/bash

# 先替换文本，然后打印结果
sed -n 's/old/new/gp' filename
```

这里，`-n`抑制了默认的自动打印，`p`命令用来打印匹配的行。

### 8.4 过滤输出

使用`sed`过滤不需要的输出。

```bash
#!/bin/bash

# 仅打印包含特定模式的行
sed -n '/pattern/p' filename
```

### 8.5 文本提取

从文本中提取特定信息。

```bash
#!/bin/bash

# 提取第一列数据
sed -n 's/[^,]*,\([^\n]*\)/\1/p' filename
```

### 8.6 删除行

删除文件中的特定行。

```bash
#!/bin/bash

# 删除包含特定模式的行
sed -i '/pattern/d' filename
```

### 8.7 增加行

在文件的特定位置增加行。

```bash
#!/bin/bash

# 在第一行后增加新行
sed -i '1i\New line' filename
```

### 8.8 文件替换

在脚本中替换多个文件中的文本。

```bash
#!/bin/bash

# 替换所有文件中的'old'为'new'
for file in *.txt; do
    sed -i 's/old/new/g' "$file"
done
```

### 注意事项

- 使用`-i`选项时，`sed`会直接修改文件。如果你不确定替换结果，可以先使用`sed`的输出功能来查看将要进行的修改。
- 在使用`sed`进行替换时，注意转义字符的使用。例如，如果文本中包含斜杠`/`，你需要用双斜杠`//`来转义。
- 如果你的模式或替换文本包含空格，确保它们被引号包围，以避免shell解释错误。
